"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndySdkHolderService = void 0;
const anoncreds_1 = require("@aries-framework/anoncreds");
const core_1 = require("@aries-framework/core");
const error_1 = require("../../error");
const types_1 = require("../../types");
const assertIndySdkWallet_1 = require("../../utils/assertIndySdkWallet");
const identifiers_1 = require("../utils/identifiers");
const transform_1 = require("../utils/transform");
const IndySdkRevocationService_1 = require("./IndySdkRevocationService");
let IndySdkHolderService = class IndySdkHolderService {
    constructor(indyRevocationService, indySdk) {
        this.indySdk = indySdk;
        this.indyRevocationService = indyRevocationService;
    }
    async createLinkSecret(agentContext, options) {
        var _a;
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        const linkSecretId = (_a = options.linkSecretId) !== null && _a !== void 0 ? _a : core_1.utils.uuid();
        try {
            await this.indySdk.proverCreateMasterSecret(agentContext.wallet.handle, linkSecretId);
            // We don't have the value for the link secret when using the indy-sdk so we can't return it.
            return {
                linkSecretId,
            };
        }
        catch (error) {
            agentContext.config.logger.error(`Error creating link secret`, {
                error,
                linkSecretId,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async createProof(agentContext, options) {
        const { credentialDefinitions, proofRequest, selectedCredentials, schemas } = options;
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        const linkSecretRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsLinkSecretRepository);
        try {
            agentContext.config.logger.debug('Creating Indy Proof');
            const indyRevocationStates = await this.indyRevocationService.createRevocationState(agentContext, proofRequest, selectedCredentials, options.revocationRegistries);
            // The AnonCredsSchema doesn't contain the seqNo anymore. However, the indy credential definition id
            // does contain the seqNo, so we can extract it from the credential definition id.
            const seqNoMap = {};
            // Convert AnonCreds credential definitions to Indy credential definitions
            const indyCredentialDefinitions = {};
            for (const credentialDefinitionId in credentialDefinitions) {
                const credentialDefinition = credentialDefinitions[credentialDefinitionId];
                indyCredentialDefinitions[credentialDefinitionId] = (0, transform_1.indySdkCredentialDefinitionFromAnonCreds)(credentialDefinitionId, credentialDefinition);
                // Get the seqNo for the schemas so we can use it when transforming the schemas
                const { schemaSeqNo } = (0, identifiers_1.parseCredentialDefinitionId)(credentialDefinitionId);
                seqNoMap[credentialDefinition.schemaId] = Number(schemaSeqNo);
            }
            // Convert AnonCreds schemas to Indy schemas
            const indySchemas = {};
            for (const schemaId in schemas) {
                const schema = schemas[schemaId];
                indySchemas[schemaId] = (0, transform_1.indySdkSchemaFromAnonCreds)(schemaId, schema, seqNoMap[schemaId]);
            }
            const linkSecretRecord = await linkSecretRepository.findDefault(agentContext);
            if (!linkSecretRecord) {
                // No default link secret
                throw new core_1.AriesFrameworkError('No default link secret found. Indy SDK requires a default link secret to be created before creating a proof.');
            }
            const indyProof = await this.indySdk.proverCreateProof(agentContext.wallet.handle, proofRequest, this.parseSelectedCredentials(selectedCredentials), linkSecretRecord.linkSecretId, indySchemas, indyCredentialDefinitions, indyRevocationStates);
            agentContext.config.logger.trace('Created Indy Proof', {
                indyProof,
            });
            return indyProof;
        }
        catch (error) {
            agentContext.config.logger.error(`Error creating Indy Proof`, {
                error,
                proofRequest,
                selectedCredentials,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async storeCredential(agentContext, options) {
        var _a;
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        const indyRevocationRegistryDefinition = options.revocationRegistry
            ? (0, transform_1.indySdkRevocationRegistryDefinitionFromAnonCreds)(options.revocationRegistry.id, options.revocationRegistry.definition)
            : null;
        try {
            return await this.indySdk.proverStoreCredential(agentContext.wallet.handle, (_a = options.credentialId) !== null && _a !== void 0 ? _a : null, 
            // The type is typed as a Record<string, unknown> in the indy-sdk, but the anoncreds package contains the correct type
            options.credentialRequestMetadata, options.credential, (0, transform_1.indySdkCredentialDefinitionFromAnonCreds)(options.credentialDefinitionId, options.credentialDefinition), indyRevocationRegistryDefinition);
        }
        catch (error) {
            agentContext.config.logger.error(`Error storing Indy Credential '${options.credentialId}'`, {
                error,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async getCredential(agentContext, options) {
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        try {
            const result = await this.indySdk.proverGetCredential(agentContext.wallet.handle, options.credentialId);
            return {
                credentialDefinitionId: result.cred_def_id,
                attributes: result.attrs,
                credentialId: result.referent,
                schemaId: result.schema_id,
                credentialRevocationId: result.cred_rev_id,
                revocationRegistryId: result.rev_reg_id,
            };
        }
        catch (error) {
            agentContext.config.logger.error(`Error getting Indy Credential '${options.credentialId}'`, {
                error,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async getCredentials(agentContext, options) {
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        const credentials = await this.indySdk.proverGetCredentials(agentContext.wallet.handle, {
            cred_def_id: options.credentialDefinitionId,
            schema_id: options.schemaId,
            schema_issuer_did: options.schemaIssuerId,
            schema_name: options.schemaName,
            schema_version: options.schemaVersion,
            issuer_did: options.issuerId,
        });
        return credentials.map((credential) => ({
            credentialDefinitionId: credential.cred_def_id,
            attributes: credential.attrs,
            credentialId: credential.referent,
            schemaId: credential.schema_id,
            credentialRevocationId: credential.cred_rev_id,
            revocationRegistryId: credential.rev_reg_id,
        }));
    }
    async createCredentialRequest(agentContext, options) {
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        if (!options.useLegacyProverDid) {
            throw new core_1.AriesFrameworkError('Indy SDK only supports legacy prover did for credential requests');
        }
        const linkSecretRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsLinkSecretRepository);
        // We just generate a prover did like string, as it's not used for anything and we don't need
        // to prove ownership of the did. It's deprecated in AnonCreds v1, but kept for backwards compatibility
        const proverDid = (0, anoncreds_1.generateLegacyProverDidLikeString)();
        // If a link secret is specified, use it. Otherwise, attempt to use default link secret
        const linkSecretRecord = options.linkSecretId
            ? await linkSecretRepository.getByLinkSecretId(agentContext, options.linkSecretId)
            : await linkSecretRepository.findDefault(agentContext);
        if (!linkSecretRecord) {
            // No default link secret
            throw new core_1.AriesFrameworkError('No link secret provided to createCredentialRequest and no default link secret has been found');
        }
        try {
            const result = await this.indySdk.proverCreateCredentialReq(agentContext.wallet.handle, proverDid, options.credentialOffer, 
            // NOTE: Is it safe to use the cred_def_id from the offer? I think so. You can't create a request
            // for a cred def that is not in the offer
            (0, transform_1.indySdkCredentialDefinitionFromAnonCreds)(options.credentialOffer.cred_def_id, options.credentialDefinition), linkSecretRecord.linkSecretId);
            return {
                credentialRequest: result[0],
                // The type is typed as a Record<string, unknown> in the indy-sdk, but the anoncreds package contains the correct type
                credentialRequestMetadata: result[1],
            };
        }
        catch (error) {
            agentContext.config.logger.error(`Error creating Indy Credential Request`, {
                error,
                credentialOffer: options.credentialOffer,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async deleteCredential(agentContext, credentialId) {
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        try {
            return await this.indySdk.proverDeleteCredential(agentContext.wallet.handle, credentialId);
        }
        catch (error) {
            agentContext.config.logger.error(`Error deleting Indy Credential from Wallet`, {
                error,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async getCredentialsForProofRequest(agentContext, options) {
        var _a, _b;
        (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
        try {
            // Open indy credential search
            const searchHandle = await this.indySdk.proverSearchCredentialsForProofReq(agentContext.wallet.handle, options.proofRequest, (_a = options.extraQuery) !== null && _a !== void 0 ? _a : null);
            const start = (_b = options.start) !== null && _b !== void 0 ? _b : 0;
            try {
                // Make sure database cursors start at 'start' (bit ugly, but no way around in indy)
                if (start > 0) {
                    await this.fetchCredentialsForReferent(agentContext, searchHandle, options.attributeReferent, start);
                }
                // Fetch the credentials
                const credentials = await this.fetchCredentialsForReferent(agentContext, searchHandle, options.attributeReferent, options.limit);
                // TODO: sort the credentials (irrevocable first)
                return credentials.map((credential) => ({
                    credentialInfo: {
                        credentialDefinitionId: credential.cred_info.cred_def_id,
                        credentialId: credential.cred_info.referent,
                        attributes: credential.cred_info.attrs,
                        schemaId: credential.cred_info.schema_id,
                        revocationRegistryId: credential.cred_info.rev_reg_id,
                        credentialRevocationId: credential.cred_info.cred_rev_id,
                    },
                    interval: credential.interval,
                }));
            }
            finally {
                // Always close search
                await this.indySdk.proverCloseCredentialsSearchForProofReq(searchHandle);
            }
        }
        catch (error) {
            if ((0, error_1.isIndyError)(error)) {
                throw new error_1.IndySdkError(error);
            }
            throw error;
        }
    }
    async fetchCredentialsForReferent(agentContext, searchHandle, referent, limit) {
        try {
            let credentials = [];
            // Allow max of 256 per fetch operation
            const chunk = limit ? Math.min(256, limit) : 256;
            // Loop while limit not reached (or no limit specified)
            while (!limit || credentials.length < limit) {
                // Retrieve credentials
                const credentialsJson = await this.indySdk.proverFetchCredentialsForProofReq(searchHandle, referent, chunk);
                credentials = [...credentials, ...credentialsJson];
                // If the number of credentials returned is less than chunk
                // It means we reached the end of the iterator (no more credentials)
                if (credentialsJson.length < chunk) {
                    return credentials;
                }
            }
            return credentials;
        }
        catch (error) {
            agentContext.config.logger.error(`Error Fetching Indy Credentials For Referent`, {
                error,
            });
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /**
     * Converts a public api form of {@link AnonCredsSelectedCredentials} interface into a format {@link Indy.IndyRequestedCredentials} that Indy SDK expects.
     **/
    parseSelectedCredentials(selectedCredentials) {
        const indyRequestedCredentials = {
            requested_attributes: {},
            requested_predicates: {},
            self_attested_attributes: {},
        };
        for (const groupName in selectedCredentials.attributes) {
            indyRequestedCredentials.requested_attributes[groupName] = {
                cred_id: selectedCredentials.attributes[groupName].credentialId,
                revealed: selectedCredentials.attributes[groupName].revealed,
                timestamp: selectedCredentials.attributes[groupName].timestamp,
            };
        }
        for (const groupName in selectedCredentials.predicates) {
            indyRequestedCredentials.requested_predicates[groupName] = {
                cred_id: selectedCredentials.predicates[groupName].credentialId,
                timestamp: selectedCredentials.predicates[groupName].timestamp,
            };
        }
        return indyRequestedCredentials;
    }
};
IndySdkHolderService = __decorate([
    (0, core_1.injectable)(),
    __param(1, (0, core_1.inject)(types_1.IndySdkSymbol)),
    __metadata("design:paramtypes", [IndySdkRevocationService_1.IndySdkRevocationService, Object])
], IndySdkHolderService);
exports.IndySdkHolderService = IndySdkHolderService;
//# sourceMappingURL=IndySdkHolderService.js.map