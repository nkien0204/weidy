"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndySdkPool = void 0;
const core_1 = require("@aries-framework/core");
const error_1 = require("../error");
const error_2 = require("./error");
const util_1 = require("./util");
class IndySdkPool {
    constructor(poolConfig, indySdk, logger, stop$, fileSystem) {
        this.indySdk = indySdk;
        this.fileSystem = fileSystem;
        this.poolConfig = poolConfig;
        this.logger = logger;
        // Listen to stop$ (shutdown) and close pool
        stop$.subscribe(async () => {
            if (this._poolHandle) {
                await this.close();
            }
        });
    }
    get didIndyNamespace() {
        return this.config.indyNamespace;
    }
    get id() {
        return this.poolConfig.id;
    }
    get config() {
        return this.poolConfig;
    }
    async close() {
        const poolHandle = this._poolHandle;
        if (!poolHandle) {
            return;
        }
        this._poolHandle = undefined;
        this.poolConnected = undefined;
        await this.indySdk.closePoolLedger(poolHandle);
    }
    async delete() {
        // Close the pool if currently open
        if (this._poolHandle) {
            await this.close();
        }
        await this.indySdk.deletePoolLedgerConfig(this.poolConfig.indyNamespace);
    }
    async connect() {
        if (!this.poolConnected) {
            // Save the promise of connectToLedger to determine if we are done connecting
            this.poolConnected = this.connectToLedger();
            this.poolConnected.catch((error) => {
                // Set poolConnected to undefined so we can retry connection upon failure
                this.poolConnected = undefined;
                this.logger.error('Connection to pool: ' + this.poolConfig.genesisPath + ' failed.', { error });
            });
            return this.poolConnected;
        }
        else {
            throw new core_1.AriesFrameworkError('Cannot attempt connection to ledger, already connecting.');
        }
    }
    async connectToLedger() {
        var _a;
        const poolName = (_a = this.poolConfig.id) !== null && _a !== void 0 ? _a : this.poolConfig.indyNamespace;
        const genesisPath = await this.getGenesisPath();
        if (!genesisPath) {
            throw new core_1.AriesFrameworkError('Cannot connect to ledger without genesis file');
        }
        this.logger.debug(`Connecting to ledger pool '${poolName}'`, { genesisPath });
        await this.indySdk.setProtocolVersion(2);
        try {
            this._poolHandle = await this.indySdk.openPoolLedger(poolName);
            return;
        }
        catch (error) {
            if (!(0, error_1.isIndyError)(error, 'PoolLedgerNotCreatedError')) {
                throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
            }
        }
        this.logger.debug(`Pool '${poolName}' does not exist yet, creating.`, {
            indyError: 'PoolLedgerNotCreatedError',
        });
        try {
            await this.indySdk.createPoolLedgerConfig(poolName, { genesis_txn: genesisPath });
            this._poolHandle = await this.indySdk.openPoolLedger(poolName);
            return;
        }
        catch (error) {
            throw (0, error_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    async submitRequest(request) {
        return this.indySdk.submitRequest(await this.getPoolHandle(), request);
    }
    async submitReadRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, util_1.isLedgerRejectResponse)(response) || (0, util_1.isLedgerReqnackResponse)(response)) {
            throw new error_2.IndySdkPoolError(`Ledger '${this.didIndyNamespace}' rejected read transaction request: ${response.reason}`);
        }
        return response;
    }
    async submitWriteRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, util_1.isLedgerRejectResponse)(response) || (0, util_1.isLedgerReqnackResponse)(response)) {
            throw new error_2.IndySdkPoolError(`Ledger '${this.didIndyNamespace}' rejected write transaction request: ${response.reason}`);
        }
        return response;
    }
    async getPoolHandle() {
        if (this.poolConnected) {
            // If we have tried to already connect to pool wait for it
            try {
                await this.poolConnected;
            }
            catch (error) {
                this.logger.error('Connection to pool: ' + this.poolConfig.genesisPath + ' failed.', { error });
            }
        }
        if (!this._poolHandle)
            await this.connect();
        if (!this._poolHandle)
            throw new error_2.IndySdkPoolError('Pool handle not set after connection');
        return this._poolHandle;
    }
    async getGenesisPath() {
        var _a;
        // If the path is already provided return it
        if (this.poolConfig.genesisPath)
            return this.poolConfig.genesisPath;
        // Determine the genesisPath
        const genesisPath = this.fileSystem.tempPath + `/genesis-${(_a = this.poolConfig.id) !== null && _a !== void 0 ? _a : this.poolConfig.indyNamespace}.txn`;
        // Store genesis data if provided
        if (this.poolConfig.genesisTransactions) {
            await this.fileSystem.write(genesisPath, this.poolConfig.genesisTransactions);
            this.poolConfig.genesisPath = genesisPath;
            return genesisPath;
        }
        // No genesisPath
        return null;
    }
}
exports.IndySdkPool = IndySdkPool;
//# sourceMappingURL=IndySdkPool.js.map