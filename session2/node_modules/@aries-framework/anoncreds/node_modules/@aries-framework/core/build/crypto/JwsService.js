"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var JwsService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwsService = void 0;
const error_1 = require("../error");
const plugins_1 = require("../plugins");
const utils_1 = require("../utils");
const error_2 = require("../wallet/error");
const Key_1 = require("./Key");
const KeyType_1 = require("./KeyType");
// TODO: support more key types, more generic jws format
const JWS_KEY_TYPE = 'OKP';
const JWS_CURVE = 'Ed25519';
const JWS_ALG = 'EdDSA';
let JwsService = JwsService_1 = class JwsService {
    async createJwsBase(agentContext, options) {
        if (!JwsService_1.supportedKeyTypes.includes(options.key.keyType)) {
            throw new error_1.AriesFrameworkError(`Only ${JwsService_1.supportedKeyTypes.join(',')} key type(s) supported for creating JWS`);
        }
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(options.payload);
        const base64UrlProtectedHeader = utils_1.JsonEncoder.toBase64URL(this.buildProtected(options.protectedHeaderOptions));
        const signature = utils_1.TypedArrayEncoder.toBase64URL(await agentContext.wallet.sign({
            data: utils_1.TypedArrayEncoder.fromString(`${base64UrlProtectedHeader}.${base64Payload}`),
            key: options.key,
        }));
        return {
            base64Payload,
            base64UrlProtectedHeader,
            signature,
        };
    }
    async createJws(agentContext, { payload, key, header, protectedHeaderOptions }) {
        const { base64UrlProtectedHeader, signature } = await this.createJwsBase(agentContext, {
            payload,
            key,
            protectedHeaderOptions,
        });
        return {
            protected: base64UrlProtectedHeader,
            signature,
            header,
        };
    }
    /**
     *  @see {@link https://www.rfc-editor.org/rfc/rfc7515#section-3.1}
     * */
    async createJwsCompact(agentContext, { payload, key, protectedHeaderOptions }) {
        const { base64Payload, base64UrlProtectedHeader, signature } = await this.createJwsBase(agentContext, {
            payload,
            key,
            protectedHeaderOptions,
        });
        return `${base64UrlProtectedHeader}.${base64Payload}.${signature}`;
    }
    /**
     * Verify a JWS
     */
    async verifyJws(agentContext, { jws, payload }) {
        var _a, _b, _c;
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(payload);
        const signatures = 'signatures' in jws ? jws.signatures : [jws];
        if (signatures.length === 0) {
            throw new error_1.AriesFrameworkError('Unable to verify JWS: No entries in JWS signatures array.');
        }
        const signerKeys = [];
        for (const jws of signatures) {
            const protectedJson = utils_1.JsonEncoder.fromBase64(jws.protected);
            const isValidKeyType = ((_a = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _a === void 0 ? void 0 : _a.kty) === JWS_KEY_TYPE;
            const isValidCurve = ((_b = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _b === void 0 ? void 0 : _b.crv) === JWS_CURVE;
            const isValidAlg = (protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.alg) === JWS_ALG;
            if (!isValidKeyType || !isValidCurve || !isValidAlg) {
                throw new error_1.AriesFrameworkError('Invalid protected header');
            }
            const data = utils_1.TypedArrayEncoder.fromString(`${jws.protected}.${base64Payload}`);
            const signature = utils_1.TypedArrayEncoder.fromBase64(jws.signature);
            const publicKey = utils_1.TypedArrayEncoder.fromBase64((_c = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _c === void 0 ? void 0 : _c.x);
            const key = Key_1.Key.fromPublicKey(publicKey, KeyType_1.KeyType.Ed25519);
            signerKeys.push(key);
            try {
                const isValid = await agentContext.wallet.verify({ key, data, signature });
                if (!isValid) {
                    return {
                        isValid: false,
                        signerKeys: [],
                    };
                }
            }
            catch (error) {
                // WalletError probably means signature verification failed. Would be useful to add
                // more specific error type in wallet.verify method
                if (error instanceof error_2.WalletError) {
                    return {
                        isValid: false,
                        signerKeys: [],
                    };
                }
                throw error;
            }
        }
        return { isValid: true, signerKeys: signerKeys };
    }
    buildProtected(options) {
        if (!options.jwk && !options.kid) {
            throw new error_1.AriesFrameworkError('Both JWK and kid are undefined. Please provide one or the other.');
        }
        if (options.jwk && options.kid) {
            throw new error_1.AriesFrameworkError('Both JWK and kid are provided. Please only provide one of the two.');
        }
        return {
            alg: options.alg,
            jwk: options.jwk,
            kid: options.kid,
        };
    }
};
JwsService.supportedKeyTypes = [KeyType_1.KeyType.Ed25519];
JwsService = JwsService_1 = __decorate([
    (0, plugins_1.injectable)()
], JwsService);
exports.JwsService = JwsService;
//# sourceMappingURL=JwsService.js.map